### 作用域基本概念（Scope）

标识符（变量，常量，类型，函数）的可见范围（可见的意思是可以使用这个标识符，比如调用啥的）  

Go 的作用域是**词法作用域**，在编译时就能确定变量在哪里可见  

声明的位置决定了作用域  

### 作用域层次（由小到大）

1. 局部作用域

在函数内部声明的变量，只在该函数或语句块内可见，离开该函数/语句块就失效。  

```go
func demo() {
    x := 10
    fmt.Println(x) // ✅ 有效
}
// fmt.Println(x) // ❌ 报错：undefined
```

2. 包作用域（包内函数外，以 **小写字母开头**）

在函数外部声明的标识符（变量，常量，类型，函数）  

在当前这个包中全部可见（同一个 package 下的所有.go 文件）  

```go
// file a.go
package mypkg

var hidden = 123 // 小写开头：仅包内可见

// file b.go (同一个包 mypkg)
fmt.Println(hidden) // ✅ 可以访问
```

3. 导出作用域（包内函数外，以**大写字母开头**）

可以被其他包导入使用

```go
package mypkg

var Hidden = 100 // 首字母大写：导出
```

```go
package main

import "mypkg"

func main() {
    fmt.Println(mypkg.Hidden) // ✅ 可以访问
}
```

这里我们在 mypkg 中声明了Hidden 变量，在其他 package 中，我们需要通过导入 mypkg 包来使用Hidden 这个量  

使用**包名.变量名**的方式来访问，不要漏掉包名，防止有同名变量的情况

4. 文件作用域

通过 import 导入的包名，只在当前文件里可见。

### 特殊的作用域规则

1. 短变量声明（:=）

只能在函数内部用  

如果左边有一个至少新变量，就算合法；否则报错

```go
x := 1
x, y := 2, 3 //正确，因为 y 是新变量，x 会被重新赋值为 2
x, y := 4, 5 //错误，因为 x 和 y 都已经声明过，没有新变量
```

2. 变量遮蔽（shadowing）

内层作用域声明的变量会**遮蔽（覆盖）**外层同名变量  

原因：访问时会优先用最近作用域**（就近原则）**  

```go
x := 1
func demo() {
    x := 2
    fmt.Println(x) // 输出 2，而不是外层的 1
}
fmt.Println(x) // 输出 1， 而不是内层的 2
```

3. 常量作用域

常量（const）和变量一样，也遵循相同作用域规则。  

特殊：iota 只能在 const 声明块里用。