# Go 函数作为“值”的四种常见用法

在 Go 里，**函数是一等公民**：它可以像 `int`、`string` 一样存变量、放集合、挂在结构体、甚至通过通道传输。调用时只需在函数变量/表达式后加 `()`。

------

## 1. 函数变量 (Function Variable)

**概念**：把函数赋值给变量，再通过变量调用。

```go
fn := func(x int) int {
    return x + 1
}
fmt.Println(fn(10)) // 输出 11
```

📌 场景：临时定义一个小函数、回调函数、替代命名函数。

------

## 2. 函数切片 (Slice of Functions)

**概念**：把多个函数放进切片（类似“函数数组”），用下标取出调用。

```go
fns := []func(int) int{
    func(x int) int { return x + 1 },
    func(x int) int { return x + 2 },
}
fmt.Println(fns ) // 输出 101
fmt.Println(fns ) // 输出 102
```

📌 场景：一组策略/操作，用索引或循环动态调用。

------

## 3. 函数作为结构体字段 (Function as Struct Field)

**概念**：结构体字段的类型可以是函数，调用时通过 `实例.字段名()`。

```go
type MyStruct struct {
    fn func(string) string
}

d := MyStruct{
    fn: func(name string) string { return "Hello, " + name },
}
fmt.Println(d.fn("Lewis")) // 输出 Hello, Lewis
```

📌 场景：给对象注入不同的“行为”，实现回调、策略模式、依赖注入。

------

## 4. 函数通道 (Channel of Functions)

**概念**：通道也可以传递函数，在并发场景下把“任务逻辑”发送给其他 goroutine 执行。

```go
fc := make(chan func() string, 1)

// 发送函数
fc <- func() string { return "Hello, World!" }

// 接收并调用
f := <-fc
fmt.Println(f()) // 输出 Hello, World!
```

📌 场景：任务分发、异步执行，把逻辑作为消息传递。

------

# 总结口诀

- **变量存函数** → `fn()` 调用
- **切片存函数** → `fns[i](...)` 调用
- **结构体存函数** → `s.fn(...)` 调用
- **通道传函数** → `<-ch` 取出再 `()` 调用

👉 本质上没区别：只是**函数值的存放位置不同**。